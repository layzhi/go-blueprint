package database

import (
	"context"
	"fmt"
	"log"
	"math"
	"os"
	"strconv"
	"strings"
	"time"

	_ "github.com/joho/godotenv/autoload"
	"github.com/redis/go-redis/v9"
)

type Service interface {
	Health() map[string]string
}

type service struct {
	db *redis.Client
}

var (
	address  = os.Getenv("BLUEPRINT_DB_ADDRESS")
	port     = os.Getenv("BLUEPRINT_DB_PORT")
	password = os.Getenv("BLUEPRINT_DB_PASSWORD")
	database = os.Getenv("BLUEPRINT_DB_DATABASE")
)

func New() Service {
	num, err := strconv.Atoi(database)
	if err != nil {
		log.Fatalf("database incorrect %v", err)
	}

	fullAddress := fmt.Sprintf("%s:%s", address, port)

	rdb := redis.NewClient(&redis.Options{
		Addr:     fullAddress,
		Password: password,
		DB:       num,
		// Note: It's important to add this for a secure connection. Most cloud services that offer Redis should already have this configured in their services.
		// For manual setup, please refer to the Redis documentation: https://redis.io/docs/latest/operate/oss_and_stack/management/security/encryption/
		// TLSConfig: &tls.Config{
		// 	MinVersion:   tls.VersionTLS12,
		// },
	})

	s := &service{db: rdb}

	return s
}

// Health returns the health status and statistics of the Redis server.
func (s *service) Health() map[string]string {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) // Default is now 5s
	defer cancel()

	stats := make(map[string]string)

	// Ping the Redis server to check its availability.
	_, err := s.db.Ping(ctx).Result()
	// Note: By extracting and simplifying like this, `log.Fatalf("db down: %v", err)`
	// can be changed into a standard error instead of a fatal error.
	if err != nil {
		log.Printf("db down: %v", err)
	}

	// Redis is up
	stats["redis_status"] = "up"
	stats["redis_message"] = "It's healthy"

	return stats
}

// parseRedisInfo parses the Redis info response and returns a map of key-value pairs.
func parseRedisInfo(info string) map[string]string {
	result := make(map[string]string)
	lines := strings.Split(info, "\r\n")
	for _, line := range lines {
		if strings.Contains(line, ":") {
			parts := strings.Split(line, ":")
			key := strings.TrimSpace(parts[0])
			value := strings.TrimSpace(parts[1])
			result[key] = value
		}
	}
	return result
}
